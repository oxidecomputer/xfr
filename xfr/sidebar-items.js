initSidebarItems({"enum":[["Error",""]],"fn":[["ring","The ring function creates a [`Ring`] object and returns a [`RingProducer`] and [`RingConsumer`] instance for interacting with the [`Ring`]."]],"struct":[["Frame","A Frame is a wrapper for a network data frame. The data inside is owned by this frame."],["FrameBuffer","A frame buffer holds an array of frames and an index that identifies the first allocatable frames. Frames are always allocated in a forward linear fashion. There is no tracking of allocated frames. If your frame gets overwritten, itâ€™s because you held on to it too long. Users of a frame buffer should ensure that the buffer is sufficiently sized to allow external holders of frames to do what they must with them before they are reallocated e.g., frames come with an expiration of one ring epoch. This is essentially a big linear ring of frames. The focus is on fast allocation. Allocations against this frame are expected at rates in the millions to tens of millions per second."],["FrameBufferIterator","An iterator over a set of frames. In the event that a series of frames rolls over from the end of the buffer to the beginning this iterator handles that seamlessly."],["Ring","A Ring arbitrates access to a frame buffer. Rings are directional, there are producers that allocate and modify and produce elements on one side of a ring and consumers that read and consume frames on the other side of a ring. A ring contains ring elements which are essentially a wrapper around a FrameBuffer specific address."],["RingConsumer","A [`RingConsumer`] provides read access to a [`Ring`]."],["RingElement","A wring element is a wrapper around an address to a [`Frame`] within a [`FrameBuffer`]."],["RingIterator","An iterator over a set of [`RingElement`]s. In the event that a series of elements rolls over from the end of the ring to the beginning, this iterator handles that seamlessly."],["RingProducer","A [`RingProducer`] provides write access to a [`Ring`]."]]});